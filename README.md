# Quine-McCluskey

# امیر حسین قدرتی 40324983

پروژه پیاده‌سازی الگوریتم Quine-McCluskey که برای ساده‌سازی توابع بولی (منطقی) به‌صورت SOP (Sum of Products) استفاده میشه. 

ورودی‌های برنامه:

تعداد متغیرها (مثلاً 3 متغیر)

نام متغیرها (مثلاً ABC)

لیستی از شماره‌ی مین‌ترم‌ها (minterms) که تابع برای اونها مقدار 1 داره

لیستی از شماره‌ی don't careها (اختیاری) که تو تابع اهمیتی ندارن و میشه ازشون برای ساده‌سازی کمک گرفت


خروجی برنامه:

نمایش ساده‌شده‌ی تابع بولی به‌صورت عبارت SOP که با + از هم جدا شدن (مثل: A'B + AC)


مراحل اجرای کد:

1. کاربر میبایست تعداد متغییر ها را وارد کند (به طور مثال 3 متغییر).


2. بعد از اون، حروف مربوط به متغیرها وارد میشه (مثلاً ABC).


3. لیست مین‌ترم‌ها وارد میشه (مثلاً 0 1 2 5).


4. در صورت وجود، لیست don’t careها هم وارد میشه (یا خالی گذاشته میشه).


5. بعد از وارد کردن ورودی‌ها، برنامه تابع رو با الگوریتم Quine-McCluskey ساده می‌کنه و خروجی نهایی یعنی تابع ساده‌شده رو نشون میده.

 
 توضیحات کامل راجب کدهای پروژه:
 
# توضیح متد decimal_to_binary
این متد برای تبدیل اعداد دهدهی (مبنای ۱۰) به نمایش دودویی (مبنای ۲) با طول ثابت طراحی شده است. این تبدیل برای الگوریتم Quine-McCluskey ضروری است، چرا که این الگوریتم بر اساس الگوهای بیتی کار می‌کند.

پارامترهای ورودی:
minterms: لیستی از اعداد دهدهی که نشان‌دهنده مینترم‌های تابع بولین هستند

num_vars: تعداد متغیرهای تابع بولین (تعیین‌کننده طول رشته دودویی)
 
# توضیح متد compare_terms
این متد دو رشته دودویی (که نمایانگر مینترم‌ها هستند) را مقایسه می‌کند تا مشخص کند آیا می‌توان آنها را با هم ترکیب کرد یا خیر. این یک بخش اساسی از الگوریتم Quine-McCluskey است.

پارامترهای ورودی:
term1: رشته دودویی اول (مثلاً "010")

term2: رشته دودویی دوم (مثلاً "011")

خروجی:
اگر دو ترم دقیقاً در یک بیت تفاوت داشته باشند:

رشته جدید با '-' در موقعیت بیت متفاوت (مثلاً "01-")

در غیر این صورت:

None (نشان‌دهنده عدم امکان ترکیب)

# توضیح متد combine_terms
این متد هسته اصلی الگوریتم Quine-McCluskey را پیاده‌سازی می‌کند و مسئول ترکیب ترم‌های مجاور برای ساده‌سازی تابع بولین است.
این متد مرحله اصلی ترکیب ترم‌ها را انجام می‌دهد

با هر بار فراخوانی، یک لایه از ساده‌سازی انجام می‌شود

خروجی:
یک تاپل (tuple) شامل دو بخش:

list(combined): لیست ترم‌های ترکیب شده جدید

leftovers: ترم‌هایی که نتوانسته‌اند با هیچ ترم دیگری ترکیب شوند

# توضیح متد find_prime_implicants
این متد مسئول یافتن تمام ایمپلیکانت‌های اولیه (Prime Implicants) در الگوریتم Quine-McCluskey است. ایمپلیکانت‌های اولیه مهم‌ترین بخش‌های تابع بولین هستند که نمی‌توان آنها را بیشتر ساده کرد

اضافه کردن آخرین ترم‌های ترکیب شده به نتایج

حذف موارد تکراری با تبدیل به مجموعه (set)

برگرداندن لیست نهایی

همیت در الگوریتم:
این متد تمام گروه‌های ممکن از مینترم‌ها را پیدا می‌کند

خروجی آن شامل تمام اصطلاحاتی است که نمی‌توانند بیشتر ساده شوند

این ایمپلیکانت‌های اولیه در مراحل بعدی برای یافتن پوشش حداقلی استفاده می‌شوند

# توضیح متد get_covered_minterms
این متد تعیین می‌کند که کدام یک از مینترم‌های اصلی توسط یک ایمپلیکانت اولیه (prime implicant) پوشش داده می‌شوند.

اهمیت در الگوریتم:
این متد برای ساختن جدول پوشش (covering table) استفاده می‌شود

به شناسایی ایمپلیکانت‌های اساسی کمک می‌کند

# توضیح جامع متد expand_to_full_terms
این متد مسئول تبدیل ایمپلیکانت‌های اولیه (prime implicants) به فرم جبری استاندارد (عبارت‌های SOP) است. این تبدیل نهایی برای نمایش خروجی قابل خواندن توسط انسان ضروری اس

نحوه کار دقیق:
1. تابع داخلی expand_term:
این تابع هر ایمپلیکانت را به تمام حالت‌های ممکن گسترش می‌دهد:

شناسایی موقعیت‌های بی‌تفاوت ('-'):

پیدا کردن تمام اندیس‌هایی که کاراکتر '-' دارند

تولید ترکیب‌های ممکن:

استفاده از product('01', ...) برای تولید تمام ترکیب‌های بیتی ممکن

مثال: برای دو موقعیت بی‌تفاوت → ['00', '01', '10', '11']

جایگزینی و ساخت ترم‌های کامل:

برای هر ترکیب، '-'‌ها را با مقادیر 0 یا 1 جایگزین می‌کند

مثال: "0-1" با ترکیبات → ["001", "011"]

2. بخش اصلی:
برای هر ایمپلیکانت اولیه:

گسترش به فرم دودویی کامل:

استفاده از expand_term برای تبدیل به تمام حالت‌های ممکن

تبدیل به فرم جبری:

هر بیت '1' → نام متغیر (مثال: A)

هر بیت '0' → نام متغیر با نقیض (مثال: A')

بیت های بی تفاوت حالات مختلف تولید میکنند

# توضیح متد find_essential_primes
این متد مسئول شناسایی "ایمپلیکانت‌های اساسی" (Essential Prime Implicants) در الگوریتم Quine-McCluskey است. ایمپلیکانت‌های اساسی، ترم‌هایی هستند که تنها پوشش‌دهنده یک یا چند مینترم خاص می‌باشند و برای پوشش کامل تابع ضروری هستند.
نحوه کار دقیق:
ساخت جدول پوشش (Covering Chart):

ایجاد یک دیکشنری که هر مینترم را به لیست ایمپلیکانت‌های پوشش‌دهنده آن نگاشت می‌کند

chart = {m: [] for m in minterms}

پر کردن جدول پوشش:

برای هر ایمپلیکانت اولیه (p):

تعیین مینترم‌هایی که توسط آن پوشش داده می‌شوند (get_covered_minterms)

اضافه کردن ایمپلیکانت به لیست پوشش‌دهنده هر مینترم مربوطه

شناسایی ایمپلیکانت‌های اساسی:

بررسی هر مینترم در جدول:

اگر فقط یک ایمپلیکانت آن را پوشش دهد (len(implicants) == 1)

و این ایمپلیکانت قبلاً به لیست اضافه نشده باشد

آنگاه این ایمپلیکانت، اساسی محسوب می‌شود

# توضیح متد find_minimum_cover
این متد آخرین مرحله از الگوریتم Quine-McCluskey را پیاده‌سازی می‌کند و مسئول یافتن کوچک‌ترین مجموعه از ایمپلیکانت‌ها است که تمام مینترم‌های تابع را پوشش می‌ده

نحوه کار گام به گام:
تعیین مینترم‌های پوشش داده نشده:

ابتدا تمام مینترم‌ها را در مجموعه uncovered قرار می‌دهد

سپس مینترم‌هایی که توسط ایمپلیکانت‌های اساسی پوشش داده می‌شوند را حذف می‌کند

بررسی حالت ساده:

اگر تمام مینترم‌ها پوشش داده شده باشند (uncovered خالی باشد)

لیست ایمپلیکانت‌های اساسی را به عنوان جواب برمی‌گرداند

تهیه لیست ایمپلیکانت‌های باقیمانده:

ایمپلیکانت‌هایی که اساسی نیستند را جدا می‌کند

جستجوی ترکیب بهینه:

با استفاده از حلقه‌های تو در تو:

از ترکیب‌های 1 تایی شروع می‌کند

به تدریج اندازه ترکیب را افزایش می‌دهد

برای هر ترکیب، بررسی می‌کند که آیا تمام مینترم‌های پوشش داده نشده را پوشش می‌دهد یا نه

اولین ترکیبی که این شرط را برآورده کند به عنوان جواب انتخاب می‌شود

برگشت جواب:

ترکیب انتخابی را با ایمپلیکانت‌های اساسی ادغام می‌کند

اگر هیچ ترکیبی پیدا نشد، فقط ایمپلیکانت‌های اساسی را برمی‌گرداند

# توضیح کامل متد quine_mccluskey
این متد، تابع اصلی و نقطه ورود الگوریتم Quine-McCluskey است که تمام مراحل ساده‌سازی تابع بولین را هماهنگ می‌کند.

مراحل اجرا:
آماده‌سازی اولیه:

تعیین تعداد متغیرها از طول لیست variables

ترکیب مینترم‌ها و شرایط بی‌تفاوت و حذف موارد تکراری

مرتب‌سازی لیست نهایی

بررسی حالت‌های خاص:

اگر هیچ مینترمی وجود نداشته باشد (not minterms)، تابع همیشه false است → "0"

اگر تعداد کل ترم‌ها برابر 2 به توان تعداد متغیرها باشد → تابع همیشه true است → "1"

یافتن ایمپلیکانت‌های اولیه:

با استفاده از find_prime_implicants تمام ترم‌های اولیه را پیدا می‌کند

این ترم‌ها نمی‌توانند بیشتر ساده شوند

شناسایی ایمپلیکانت‌های اساسی:

با find_essential_primes ترم‌هایی که حتماً باید در جواب باشند را پیدا می‌کند

همچنین جدول پوشش را ایجاد می‌کند

یافتن پوشش حداقلی:

با find_minimum_cover کوچک‌ترین مجموعه از ترم‌ها که تمام مینترم‌ها را پوشش می‌دهد پیدا می‌شود

تبدیل به فرم جبری:

ترم‌های نهایی با expand_to_full_terms به فرم متغیرها تبدیل می‌شوند

مثال: "0-1" با متغیرهای A,B,C → "A'C"

فرمت‌دهی خروجی:

ترم‌ها با " + " از هم جدا می‌شوند

اگر ترمی وجود نداشته باشد (حالت خاص) "0" برگردانده می‌شود

# توضیح بخش اصلی برنامه (Main Block)
این بخش، رابط کاربری برنامه برای پیاده‌سازی الگوریتم Quine-McCluskey است که به کاربر امکان می‌دهد اطلاعات تابع بولین خود را وارد کرده و نتیجه ساده‌شده را دریافت کند.

ساختار کلی:
این کد در یک بلوک try-except قرار گرفته تا خطاهای ورودی را به خوبی مدیریت کند و در صورت بروز خطا، پیام مناسبی به کاربر نمایش دهد.

مراحل اجرا:
دریافت تعداد متغیرها:

از کاربر می‌خواهد تعداد متغیرهای تابع را وارد کند (مثلاً 3)

این مقدار به عدد صحیح تبدیل می‌شود

دریافت نام متغیرها:

از کاربر می‌خواهد حروف متغیرها را وارد کند (مثلاً ABC)

بررسی می‌کند که تعداد حروف وارد شده با تعداد متغیرها برابر باشد

در صورت عدم تطابق، خطا ایجاد می‌کند

دریافت مینترم‌ها:

از کاربر می‌خواهد شماره مینترم‌ها را با فاصله وارد کند

اگر ورودی خالی باشد، لیست خالی در نظر گرفته می‌شود

دریافت شرایط Don't Care:

از کاربر می‌خواهد شماره شرایط بی‌تفاوت را وارد کند

این بخش اختیاری است و می‌توان ان را ننوشت.
